# FILE: app/src/game.py
# PURPOSE: Main game logic; high-level, non-spammy logging.
# GENERATED BY: Layer 0033 (curses-based main loop and rendering)
# LLM MODEL: GPT-4o (2024-06)

import os
import sys
import time
import json
from mapgen import generate_map, place_entity
from entities import Player, Adversary
from renderer import Renderer
from utils import get_terminal_size, is_open_tile, is_floor, load_config
from utils import setup_logger
import logging
import curses

# Call setup_logger() before any logging/debug statements
setup_logger()

class Game:
    def __init__(self, config):
        map_width = config["map_width"]
        map_height = config["map_height"]
        map_config = config.get("map_config", {})
        logging.info(
            f"Game start. Layer={config['LAYER']}, Map size={map_width}x{map_height}, Map config={map_config}"
        )
        self.map, (px, py), self.exit_pos = generate_map(map_width, map_height, map_config)
        self.layer = config["LAYER"]
        self.player = Player(px, py)
        self.messages = []
        self.running = True
        self.last_frame_time = time.time()
        self.fps = 0.0
        self.tick = 0

        # FOG OF WAR: tracks which tiles have been seen
        self.seen = [[False for _ in range(map_width)] for _ in range(map_height)]
        self._reveal_visible_area()

        # Extract floor tile from config for safe adversary placement
        floor_tile = map_config.get("tileset", {}).get("floor", ".")
        occupied = {(px, py)}
        try:
            ax, ay = place_entity(self.map, occupied, floor_tile)
            self.adversary = Adversary(ax, ay)
            logging.info(f"Player spawned at ({px},{py}); Adversary spawned at ({ax},{ay}); Exit at {self.exit_pos}")
        except Exception as e:
            logging.error(f"Failed to place adversary: {e}")
            raise

        self.player_slow_counter = 0

        self.viewport_width, self.viewport_height = self._get_dynamic_viewport_size()
        self.renderer = Renderer(config)

    def _get_dynamic_viewport_size(self):
        term_w, term_h = get_terminal_size()
        reserved_top = 1
        reserved_bottom = 3
        reserved_input = 1
        available_h = max(term_h - reserved_top - reserved_bottom - reserved_input, 1)
        vp_w = min(term_w, len(self.map[0]))
        vp_h = min(available_h, len(self.map))
        return vp_w, vp_h

    def run(self):
        curses.wrapper(self._curses_game_loop)

    def _curses_game_loop(self, stdscr):
        logging.info("Game loop started.")
        stdscr.nodelay(False)  # Wait for keypress each frame
        while self.running:
            frame_start = time.time()
            self.renderer.draw(stdscr, self, self.player, self.adversary, self.exit_pos)
            key = stdscr.getch()
            command = self._convert_curses_key(key)
            moved = self._handle_input(command)
            player_on_red_trail = (self.player.x, self.player.y) in self.adversary.trail
            if player_on_red_trail:
                if self.player_slow_counter == 0 and moved:
                    self.player_slow_counter = 1
                    self._add_message("You are slowed by the adversary's trail!")
                elif self.player_slow_counter > 0:
                    self.player_slow_counter -= 1
                    moved = False
                    self._add_message("You are slowed by the adversary's trail!")
            else:
                self.player_slow_counter = 0
            if moved:
                self.player.trail.add((self.player.x, self.player.y))
                self.player.explored.add((self.player.x, self.player.y))
            self._reveal_visible_area()

            self.adversary.move(self, self.player.trail, (self.player.x, self.player.y), is_floor, self._add_message)

            if (self.adversary.x, self.adversary.y) == (self.player.x, self.player.y):
                self._add_message("You lose! The adversary caught you!")
                logging.info("Game Over: Player caught by adversary.")
                self.renderer.draw(stdscr, self, self.player, self.adversary, self.exit_pos)
                stdscr.getch()
                break

            if (self.player.x, self.player.y) == self.exit_pos:
                self._add_message("You found the exit! Congratulations!")
                logging.info("Game Over: Player reached the exit and won.")
                self.renderer.draw(stdscr, self, self.player, self.adversary, self.exit_pos)
                stdscr.getch()
                break

            self.tick += 1
            frame_end = time.time()
            self._update_fps(frame_end - frame_start)

        logging.info(f"Game ended after {self.tick} ticks.")

    def _update_fps(self, frame_duration):
        self.fps = 1.0 / frame_duration if frame_duration > 0 else 0.0

    def _reveal_visible_area(self):
        px, py = self.player.x, self.player.y
        for dy in range(-2, 3):
            for dx in range(-2, 3):
                x = px + dx
                y = py + dy
                if 0 <= y < len(self.map) and 0 <= x < len(self.map[0]):
                    self.seen[y][x] = True

    def _convert_curses_key(self, key):
        if key in (ord('w'), ord('W'), curses.KEY_UP):
            return 'w'
        elif key in (ord('s'), ord('S'), curses.KEY_DOWN):
            return 's'
        elif key in (ord('a'), ord('A'), curses.KEY_LEFT):
            return 'a'
        elif key in (ord('d'), ord('D'), curses.KEY_RIGHT):
            return 'd'
        elif key in (ord('q'), ord('Q')):
            return 'q'
        else:
            return ''

    def _handle_input(self, command):
        dx, dy = 0, 0
        if command == 'w':
            dy = -1
        elif command == 's':
            dy = 1
        elif command == 'a':
            dx = -1
        elif command == 'd':
            dx = 1
        elif command == 'q':
            self.running = False
            self._add_message("Goodbye!")
            logging.info("User quit via Q key.")
            return False
        elif command == '':
            self._add_message("Invalid input! Use W/A/S/D to move, Q to quit.")
            logging.debug(f"Invalid input received (empty or non-movement key)")
            return False
        else:
            self._add_message("Invalid input! Use W/A/S/D to move, Q to quit.")
            logging.debug(f"Invalid input received: {command!r}")
            return False
        moved = self.player.move(dx, dy, self.map, is_open_tile)
        if moved:
            self.tick += 1
        else:
            self._add_message("You can't walk there.")
            logging.debug(f"Player move blocked: attempted ({dx}, {dy}) from ({self.player.x}, {self.player.y})")
        return moved

    def _add_message(self, msg):
        # Only log major game events, not every minor message
        important = (
            "You are slowed by the adversary's trail!" in msg or
            "You lose!" in msg or
            "Congratulations" in msg or
            "Invalid input" in msg
        )
        if important:
            logging.info(f"Game message: {msg}")
        self.messages.append(msg)

def main():
    config = load_config()
    game = Game(config)
    game.run()

if __name__ == "__main__":
    main()
