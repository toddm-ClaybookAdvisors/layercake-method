# entities.py
#
# PURPOSE: Modularized entity system for game actors, separating player and adversary logic with improved clarity and extensibility.
# GENERATED BY: Layer 0029 (refactor, entity modularization and readability)
# LLM MODEL: GPT-4o (2024-06)

import random
from collections import deque

# Define the four directions for adjacent movement (up, down, left, right)
DIRECTIONS = [(1, 0), (-1, 0), (0, 1), (0, -1)]

def adjacent_tiles(x, y):
    """Yield coordinates of the four directly adjacent (up/down/left/right) tiles."""
    for dx, dy in DIRECTIONS:
        yield (x + dx, y + dy)


class Entity:
    """
    Abstract base class for all moving entities in the game.
    Tracks position, trail, and explored tiles.
    """
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.trail = set()
        self.trail.add((x, y))
        self.explored = set()
        self.explored.add((x, y))

    def move(self, *args, **kwargs):
        """
        Move the entity. To be implemented by subclasses.
        """
        raise NotImplementedError("Subclasses must implement the move method.")

class Player(Entity):
    """
    Player character entity. Handles player movement and exploration tracking.
    """
    def move(self, dx, dy, game_map, is_open_tile):
        """
        Attempt to move the player by (dx, dy) if the target tile is open.

        Args:
            dx (int): Change in x coordinate.
            dy (int): Change in y coordinate.
            game_map (list of list): The current game map.
            is_open_tile (function): Function to check if tile is open.

        Returns:
            bool: True if movement was successful, False otherwise.
        """
        nx, ny = self.x + dx, self.y + dy
        if is_open_tile(game_map, nx, ny):
            self.x, self.y = nx, ny
            self.trail.add((self.x, self.y))
            self.explored.add((self.x, self.y))
            return True
        return False

class AdversaryBase(Entity):
    """
    Base class for AI-controlled adversaries.
    Encapsulates shared properties and basic exploration logic.
    """
    def __init__(self, x, y, vision_radius=2):
        super().__init__(x, y)
        self.mode = "explore"
        self.last_dir = (0, 0)
        self.locked_on = False
        self.in_hallway = False
        self.vision_radius = vision_radius

    def move(self, *args, **kwargs):
        """
        AdversaryBase does not implement movement.
        Must be overridden by subclasses.
        """
        raise NotImplementedError("AdversaryBase is abstract.")

class Adversary(AdversaryBase):
    """
    Adversary: pursues the player by following their trail, navigating hallways, 
    exploring new territory, or moving randomly.
    All logic is split into clearly named helpers for human readability.
    """

    def move(self, game, player_trail, player_pos, is_floor, add_message):
        """
        Decide and execute the adversary's next action.
        Priority:
            1. Lock onto and pursue the player via their trail.
            2. Continue moving through a hallway if in one.
            3. Explore any adjacent, unexplored floor tiles.
            4. Move randomly if no other options.
        """
        print(f"Adversary at ({self.x},{self.y}), attempting move...")
        if self.try_lock_on_to_player(game, player_trail, player_pos, is_floor, add_message):
            print("try_lock_on_to_player SUCCESS")
            return
        if self.try_follow_hallway(game, is_floor):
            print("try_follow_hallway SUCCESS")
            return
        if self.try_explore_unexplored(game, is_floor):
            print("try_explore_unexplored SUCCESS")
            return
        self.step_randomly(game, is_floor)

    def try_lock_on_to_player(self, game, player_trail, player_pos, is_floor, add_message):
        """
        If the player trail is within vision, find a path and move one step closer.
        """
        if not self.can_see_player_trail(game, player_trail, is_floor):
            self.locked_on = False
            return False

        path = self.find_path_along_trail(game, player_trail, player_pos, is_floor)
        if path and len(path) > 1:
            if not self.locked_on:
                add_message("You feel a chill... something is following your trail!")
            self.locked_on = True
            self.move_to(*path[1])
            self.mode = "trail_follow"
            return True
        self.locked_on = False
        return False

    def can_see_player_trail(self, game, player_trail, is_floor):
        """
        Check if any player trail tiles are within vision radius.
        """
        for tile in self.tiles_in_vision():
            if tile in player_trail and is_floor(game.map, *tile):
                return True
        return False

    def tiles_in_vision(self):
        """
        Yield all tiles within the adversary's vision radius.
        """
        for dx in range(-self.vision_radius, self.vision_radius + 1):
            for dy in range(-self.vision_radius, self.vision_radius + 1):
                yield (self.x + dx, self.y + dy)

    def find_path_along_trail(self, game, player_trail, player_pos, is_floor):
        """
        Use BFS to find a path to the player by traversing only the player's trail.
        Returns a list of positions or None.
        """
        from collections import deque

        start = (self.x, self.y)
        queue = deque([start])
        visited = set([start])
        prev = {}

        while queue:
            current = queue.popleft()
            if current == player_pos:
                # Reconstruct path from current to start
                path = [current]
                while path[-1] != start:
                    path.append(prev[path[-1]])
                path.reverse()
                return path
            for neighbor in adjacent_tiles(*current):
                if (neighbor not in visited and
                    neighbor in player_trail and
                    is_floor(game.map, *neighbor)):
                    visited.add(neighbor)
                    prev[neighbor] = current
                    queue.append(neighbor)
        return None

    def try_follow_hallway(self, game, is_floor):
        """
        If in a hallway, move forward if possible.
        If last_dir is not set, pick any open direction.
        """
        if not self.is_in_hallway(game, is_floor):
            return False

        dx, dy = self.last_dir

        # If last_dir is invalid (0,0), pick a direction
        if (dx, dy) == (0, 0):
            for ndx, ndy in DIRECTIONS:
                next_pos = (self.x + ndx, self.y + ndy)
                if is_floor(game.map, *next_pos):
                    # Set direction and move
                    self.last_dir = (ndx, ndy)
                    self.move_to(*next_pos)
                    return True
            return False  # No valid direction

        # Normal forward move
        forward = (self.x + dx, self.y + dy)
        if is_floor(game.map, *forward):
            if forward != (self.x, self.y):
                self.move_to(*forward)
                return True

        # Try any other valid direction except reverse
        for ndx, ndy in DIRECTIONS:
            if (ndx, ndy) == (-dx, -dy):
                continue
            next_pos = (self.x + ndx, self.y + ndy)
            if is_floor(game.map, *next_pos) and next_pos != (self.x, self.y):
                self.last_dir = (ndx, ndy)
                self.move_to(*next_pos)
                return True

        return False



    def is_in_hallway(self, game, is_floor):
        """
        Determine if this tile is a hallway (surrounded by walls on at least 2 sides).
        """
        wall_count = 0
        for neighbor in adjacent_tiles(self.x, self.y):
            if not is_floor(game.map, *neighbor):
                wall_count += 1
        return wall_count >= 2

    def try_explore_unexplored(self, game, is_floor):
        """
        Move to any adjacent, unexplored floor tile.
        """
        for neighbor in self.unexplored_neighbors(game, is_floor):
            self.move_to(*neighbor)
            self.mode = "explore"
            return True
        return False

    def unexplored_neighbors(self, game, is_floor):
        """
        Yield all adjacent unexplored floor tiles.
        """
        for neighbor in adjacent_tiles(self.x, self.y):
            if is_floor(game.map, *neighbor) and neighbor not in self.explored:
                yield neighbor

    def step_randomly(self, game, is_floor):
        neighbors = [n for n in adjacent_tiles(self.x, self.y) if is_floor(game.map, *n)]
        if not neighbors:
            print("Adversary is trapped, no valid moves.")
            return
        random.shuffle(neighbors)
        chosen = neighbors[0]
        print(f"step_randomly: moving from ({self.x}, {self.y}) to {chosen}")
        self.move_to(*chosen)
        self.mode = "explore"


    def move_to(self, x, y):
        """
        Move the adversary to (x, y) and update state.
        """
        print(f"move_to: from ({self.x},{self.y}) to ({x},{y})")
        self.last_dir = (x - self.x, y - self.y)
        self.x, self.y = x, y
        self.trail.add((x, y))
        self.explored.add((x, y))




