# entities.py
#
# PURPOSE: Modularized entity system for game actors, with Adversary AI prioritizing unexplored hallways in its search for the player's trail.
# GENERATED BY: Layer 0033 (feature, add player health/speed/vision_radius)
# LLM MODEL: GPT-4o (2024-06)

import random
from collections import deque
import logging

# Define the four directions for adjacent movement (up, down, left, right)
DIRECTIONS = [(1, 0), (-1, 0), (0, 1), (0, -1)]

def adjacent_tiles(x, y):
    """Yield coordinates of the four directly adjacent (up/down/left/right) tiles."""
    for dx, dy in DIRECTIONS:
        yield (x + dx, y + dy)

class Entity:
    """
    Abstract base class for all moving entities in the game.
    Tracks position, trail, and explored tiles.
    """
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.trail = set()
        self.trail.add((x, y))
        self.explored = set()
        self.explored.add((x, y))

    def move(self, *args, **kwargs):
        """
        Move the entity. To be implemented by subclasses.
        """
        raise NotImplementedError("Subclasses must implement the move method.")

class Player(Entity):
    """
    Player character entity. Handles player movement, exploration tracking, and core attributes.

    Attributes:
        health (int): Player's hit points. Reduced by traps/adversary; reaching 0 is defeat. Default 3.
        speed (int): Tiles per turn the player may move. Default 1.
        vision_radius (int): Number of tiles visible to the player (Fog of War). Default 3.
    """
    def __init__(self, x, y, health=3, speed=1, vision_radius=3):
        super().__init__(x, y)
        self.health = health
        self.speed = speed
        self.vision_radius = vision_radius

    def move(self, dx, dy, game_map, is_open_tile):
        """
        Attempt to move the player by (dx, dy) if the target tile is open.

        Args:
            dx (int): Change in x coordinate.
            dy (int): Change in y coordinate.
            game_map (list of list): The current game map.
            is_open_tile (function): Function to check if tile is open.

        Returns:
            bool: True if movement was successful, False otherwise.
        """
        nx, ny = self.x + dx, self.y + dy
        if is_open_tile(game_map, nx, ny):
            self.x, self.y = nx, ny
            self.trail.add((self.x, self.y))
            self.explored.add((self.x, self.y))
            return True
        return False

    def take_damage(self, amount):
        """
        Reduce player's health by 'amount'. Returns True if player survives.
        """
        self.health -= amount
        return self.health > 0

    def heal(self, amount):
        """
        Restore health by 'amount'. Does not exceed starting health (default: 3).
        """
        self.health = min(self.health + amount, 3)

class AdversaryBase(Entity):
    """
    Base class for AI-controlled adversaries.
    Encapsulates shared properties and basic exploration logic.
    """
    def __init__(self, x, y, vision_radius=2):
        super().__init__(x, y)
        self.mode = "explore"
        self.last_dir = (0, 0)
        self.locked_on = False
        self.in_hallway = False
        self.vision_radius = vision_radius

    def move(self, *args, **kwargs):
        """
        AdversaryBase does not implement movement.
        Must be overridden by subclasses.
        """
        raise NotImplementedError("AdversaryBase is abstract.")

class Adversary(AdversaryBase):
    """
    Adversary: pursues the player by following their trail, navigating hallways, 
    and now prioritizes unexplored hallways in its search for the trail.
    """

    def move(self, game, player_trail, player_pos, is_floor, add_message):
        """
        Decide and execute the adversary's next action.
        Priority:
            1. Lock onto and pursue the player via their trail.
            2. Continue moving through a hallway if in one.
            3. Seek nearest unexplored hallway tile.
            4. Seek nearest general unexplored tile.
            5. Move randomly if no other options.
        """
        if self.try_lock_on_to_player(game, player_trail, player_pos, is_floor, add_message):
            return
        if self.try_follow_hallway(game, is_floor):
            return
        if self.try_seek_hallway_frontier(game, is_floor):
            return
        if self.try_seek_general_frontier(game, is_floor):
            return
        self.step_randomly(game, is_floor)

    def try_lock_on_to_player(self, game, player_trail, player_pos, is_floor, add_message):
        """
        If the player trail is within vision, find a path and move one step closer.
        """
        if not self.can_see_player_trail(game, player_trail, is_floor):
            self.locked_on = False
            return False

        path = self.find_path_along_trail(game, player_trail, player_pos, is_floor)
        if path and len(path) > 1:
            if not self.locked_on:
                add_message("You feel a chill... something is following your trail!")
            self.locked_on = True
            self.move_to(*path[1])
            self.mode = "trail_follow"
            return True
        self.locked_on = False
        return False

    def can_see_player_trail(self, game, player_trail, is_floor):
        """
        Check if any player trail tiles are within vision radius.
        """
        for tile in self.tiles_in_vision():
            if tile in player_trail and is_floor(game.map, *tile):
                return True
        return False

    def tiles_in_vision(self):
        """
        Yield all tiles within the adversary's vision radius.
        """
        for dx in range(-self.vision_radius, self.vision_radius + 1):
            for dy in range(-self.vision_radius, self.vision_radius + 1):
                yield (self.x + dx, self.y + dy)

    def find_path_along_trail(self, game, player_trail, player_pos, is_floor):
        """
        Use BFS to find a path to the player by traversing only the player's trail.
        Returns a list of positions or None.
        """
        from collections import deque

        start = (self.x, self.y)
        queue = deque([start])
        visited = set([start])
        prev = {}

        while queue:
            current = queue.popleft()
            if current == player_pos:
                # Reconstruct path from current to start
                path = [current]
                while path[-1] != start:
                    path.append(prev[path[-1]])
                path.reverse()
                return path
            for neighbor in adjacent_tiles(*current):
                if (neighbor not in visited and
                    neighbor in player_trail and
                    is_floor(game.map, *neighbor)):
                    visited.add(neighbor)
                    prev[neighbor] = current
                    queue.append(neighbor)
        return None

    def try_follow_hallway(self, game, is_floor):
        """
        If in a hallway, move forward if possible.
        If last_dir is not set, pick any open direction.
        """
        if not self.is_in_hallway(game, is_floor):
            return False

        dx, dy = self.last_dir

        # If last_dir is invalid (0,0), pick a direction
        if (dx, dy) == (0, 0):
            for ndx, ndy in DIRECTIONS:
                next_pos = (self.x + ndx, self.y + ndy)
                if is_floor(game.map, *next_pos):
                    # Set direction and move
                    self.last_dir = (ndx, ndy)
                    self.move_to(*next_pos)
                    return True
            return False  # No valid direction

        # Normal forward move
        forward = (self.x + dx, self.y + dy)
        if is_floor(game.map, *forward):
            if forward != (self.x, self.y):
                self.move_to(*forward)
                return True

        # Try any other valid direction except reverse
        for ndx, ndy in DIRECTIONS:
            if (ndx, ndy) == (-dx, -dy):
                continue
            next_pos = (self.x + ndx, self.y + ndy)
            if is_floor(game.map, *next_pos) and next_pos != (self.x, self.y):
                self.last_dir = (ndx, ndy)
                self.move_to(*next_pos)
                return True

        return False

    def is_in_hallway(self, game, is_floor, pos=None):
        """
        Determine if this tile is a hallway (surrounded by walls on at least 2 sides).
        If pos is None, uses self.x, self.y.
        """
        x, y = pos if pos is not None else (self.x, self.y)
        wall_count = 0
        for neighbor in adjacent_tiles(x, y):
            if not is_floor(game.map, *neighbor):
                wall_count += 1
        return wall_count >= 2

    def try_seek_hallway_frontier(self, game, is_floor):
        """
        Find the nearest unexplored hallway tile ("frontier") using BFS and move one step toward it.
        """
        start = (self.x, self.y)
        queue = deque([start])
        visited = set([start])
        prev = {}

        found_hallway = None

        while queue:
            current = queue.popleft()
            for neighbor in adjacent_tiles(*current):
                if neighbor in visited:
                    continue
                if not is_floor(game.map, *neighbor):
                    continue
                visited.add(neighbor)
                prev[neighbor] = current
                # Is unexplored AND in a hallway?
                if neighbor not in self.explored and self.is_in_hallway(game, is_floor, pos=neighbor):
                    found_hallway = neighbor
                    break
                queue.append(neighbor)
            if found_hallway:
                break

        if found_hallway:
            # Reconstruct path from found_hallway to start
            path = [found_hallway]
            while path[-1] != start:
                path.append(prev[path[-1]])
            path.reverse()
            if len(path) > 1:
                self.move_to(*path[1])
                self.mode = "hallway_seek"
                return True
        return False

    def try_seek_general_frontier(self, game, is_floor):
        """
        Find the nearest unexplored floor tile ("frontier") using BFS and move one step toward it.
        """
        start = (self.x, self.y)
        queue = deque([start])
        visited = set([start])
        prev = {}

        found_frontier = None

        while queue:
            current = queue.popleft()
            for neighbor in adjacent_tiles(*current):
                if neighbor in visited:
                    continue
                if not is_floor(game.map, *neighbor):
                    continue
                visited.add(neighbor)
                prev[neighbor] = current
                if neighbor not in self.explored:
                    found_frontier = neighbor
                    break
                queue.append(neighbor)
            if found_frontier:
                break

        if found_frontier:
            path = [found_frontier]
            while path[-1] != start:
                path.append(prev[path[-1]])
            path.reverse()
            if len(path) > 1:
                self.move_to(*path[1])
                self.mode = "frontier_seek"
                return True
        return False

    def step_randomly(self, game, is_floor):
        neighbors = [n for n in adjacent_tiles(self.x, self.y) if is_floor(game.map, *n)]
        if not neighbors:
            logging.debug("Adversary is trapped, no valid moves.")
            return
        random.shuffle(neighbors)
        chosen = neighbors[0]
        logging.debug(f"step_randomly: moving from ({self.x}, {self.y}) to {chosen}")
        self.move_to(*chosen)
        self.mode = "explore"

    def move_to(self, x, y):
        """
        Move the adversary to (x, y) and update state.
        """
        self.last_dir = (x - self.x, y - self.y)
        self.x, self.y = x, y
        self.trail.add((x, y))
        self.explored.add((x, y))
