# =============================================================================
#  FILE: app/src/mapgen.py
#  PURPOSE: Dungeon map generation using config-driven parameters, row-major output, and correct floor tile for placement.
#  GENERATED BY: Layer 0028 (refactor: config-driven entity placement, floor tile required)
#  LLM MODEL: GPT-4o (2024-06)
# =============================================================================
#
# NOTE ON MAP ORIENTATION AND TRANSPOSITION:
# (see previous explanations...)
# =============================================================================

import random

def generate_map(width, height, map_config=None):
    """
    Generates a dungeon map and returns:
    - The map (2D list, row-major: map[y][x])
    - Player starting position (tuple)
    - Exit position (tuple)
    Uses options from map_config if provided, else defaults.
    """
    # ---- Config extraction ----
    defaults = {
        "max_rooms": 8,
        "room_min_size": 4,
        "room_max_size": 8,
        "tileset": {
            "wall": "#",
            "floor": "."
        },
        "seed": None
    }

    if map_config is None:
        map_config = {}

    def get_opt(key, fallback=None):
        return map_config.get(key, defaults[key] if fallback is None else fallback)

    max_rooms = get_opt("max_rooms")
    room_min_size = get_opt("room_min_size")
    room_max_size = get_opt("room_max_size")
    tileset = get_opt("tileset")
    WALL = tileset.get("wall", "#")
    FLOOR = tileset.get("floor", ".")
    seed = get_opt("seed")
    if seed is not None:
        random.seed(seed)

    class Room:
        def __init__(self, x, y, w, h):
            self.x1 = x
            self.y1 = y
            self.x2 = x + w
            self.y2 = y + h

        def center(self):
            cx = (self.x1 + self.x2) // 2
            cy = (self.y1 + self.y2) // 2
            return (cx, cy)

        def intersect(self, other):
            return (self.x1 <= other.x2 and self.x2 >= other.x1 and
                    self.y1 <= other.y2 and self.y2 >= other.y1)

    def create_empty_map(width, height):
        return [[WALL for _ in range(height)] for _ in range(width)]

    def carve_room(dmap, room):
        for x in range(room.x1, room.x2):
            for y in range(room.y1, room.y2):
                dmap[x][y] = FLOOR

    def carve_h_tunnel(dmap, x1, x2, y):
        for x in range(min(x1, x2), max(x1, x2) + 1):
            dmap[x][y] = FLOOR

    def carve_v_tunnel(dmap, y1, y2, x):
        for y in range(min(y1, y2), max(y1, y2) + 1):
            dmap[x][y] = FLOOR

    def _find_room_floor(room, dmap):
        candidates = [
            (x, y)
            for x in range(room.x1, room.x2)
            for y in range(room.y1, room.y2)
            if dmap[x][y] == FLOOR
        ]
        if candidates:
            return random.choice(candidates)
        return (room.x1, room.y1)

    dmap = create_empty_map(width, height)
    rooms = []

    for _ in range(max_rooms):
        w = random.randint(room_min_size, room_max_size)
        h = random.randint(room_min_size, room_max_size)
        x = random.randint(1, width - w - 1)
        y = random.randint(1, height - h - 1)
        new_room = Room(x, y, w, h)

        if any(new_room.intersect(other) for other in rooms):
            continue
        carve_room(dmap, new_room)

        if rooms:
            (prev_x, prev_y) = rooms[-1].center()
            (new_x, new_y) = new_room.center()
            if random.randint(0, 1) == 0:
                carve_h_tunnel(dmap, prev_x, new_x, prev_y)
                carve_v_tunnel(dmap, prev_y, new_y, new_x)
            else:
                carve_v_tunnel(dmap, prev_y, new_y, prev_x)
                carve_h_tunnel(dmap, prev_x, new_x, new_y)
        rooms.append(new_room)

    if rooms:
        sx, sy = rooms[0].center()
        if dmap[sx][sy] != FLOOR:
            sx, sy = _find_room_floor(rooms[0], dmap)
        ex, ey = rooms[-1].center()
        if dmap[ex][ey] != FLOOR:
            ex, ey = _find_room_floor(rooms[-1], dmap)
        start_x, start_y = sx, sy
        exit_x, exit_y = ex, ey
    else:
        start_x = start_y = exit_x = exit_y = 1

    dmap_row_major = [[dmap[x][y] for x in range(len(dmap))] for y in range(len(dmap[0]))]
    return dmap_row_major, (start_x, start_y), (exit_x, exit_y)

def place_entity(dmap, occupied=None, floor_tile='.'):
    """
    Returns a random (x, y) coordinate on a floor tile (specified by floor_tile) that is not in occupied.
    Raises ValueError if no valid tile is available.
    Assumes dmap is row-major (map[y][x]).
    """
    height = len(dmap)
    width = len(dmap[0])
    occupied = occupied or set()
    floor_tiles = [
        (x, y)
        for y in range(height)
        for x in range(width)
        if dmap[y][x] == floor_tile and (x, y) not in occupied
    ]
    if not floor_tiles:
        raise ValueError("No available floor tiles for entity placement!")
    return random.choice(floor_tiles)

def print_map(dmap):
    height = len(dmap)
    width = len(dmap[0])
    for y in range(height):
        line = ''.join(dmap[y][x] for x in range(width))
        print(line)

if __name__ == "__main__":
    WIDTH = 40
    HEIGHT = 22
    map_config = {
        "max_rooms": 8,
        "room_min_size": 4,
        "room_max_size": 8,
        "tileset": {
            "wall": "#",
            "floor": "."
        },
        "seed": None
    }
    dungeon_map, (start_x, start_y), (exit_x, exit_y) = generate_map(
        WIDTH, HEIGHT, map_config
    )
    print_map(dungeon_map)
    print(f"Player start: ({start_x}, {start_y})")
    print(f"Exit: ({exit_x}, {exit_y})")
