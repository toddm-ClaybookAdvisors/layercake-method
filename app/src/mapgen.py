# =============================================================================
#  FILE: app/src/mapgen.py
#  PURPOSE: Dungeon map generation using config-driven parameters, row-major output, and correct floor tile for placement.
#  GENERATED BY: Layer 0030 (add non-spammy logging to mapgen, include seed)
#  LLM MODEL: GPT-4o (2024-06)
# =============================================================================

import random
import logging

def generate_map(width, height, map_config=None):
    """
    Generates a dungeon map and returns:
    - The map (2D list, row-major: map[y][x])
    - Player starting position (tuple)
    - Exit position (tuple)
    Uses options from map_config if provided, else defaults.
    """
    # ---- Config extraction ----
    defaults = {
        "max_rooms": 8,
        "room_min_size": 4,
        "room_max_size": 8,
        "tileset": {
            "wall": "#",
            "floor": "."
        },
        "seed": None
    }

    if map_config is None:
        map_config = {}

    def get_opt(key, fallback=None):
        return map_config.get(key, defaults[key] if fallback is None else fallback)

    max_rooms = get_opt("max_rooms")
    room_min_size = get_opt("room_min_size")
    room_max_size = get_opt("room_max_size")
    tileset = get_opt("tileset")
    WALL = tileset.get("wall", "#")
    FLOOR = tileset.get("floor", ".")
    seed = get_opt("seed")

    if seed is not None:
        random.seed(seed)
        logging.debug(f"Random seed explicitly set to {seed}")
    else:
        # Always log the (pseudo-)seed actually in use for traceability
        seed = random.randint(0, 2**32 - 1)
        random.seed(seed)
        logging.debug(f"No seed provided; using generated seed {seed}")

    logging.debug(
        f"Generating map: width={width}, height={height}, max_rooms={max_rooms}, "
        f"room_size=({room_min_size}-{room_max_size}), tileset={tileset}, seed={seed}"
    )

    class Room:
        def __init__(self, x, y, w, h):
            self.x1 = x
            self.y1 = y
            self.x2 = x + w
            self.y2 = y + h

        def center(self):
            cx = (self.x1 + self.x2) // 2
            cy = (self.y1 + self.y2) // 2
            return (cx, cy)

        def intersect(self, other):
            return (self.x1 <= other.x2 and self.x2 >= other.x1 and
                    self.y1 <= other.y2 and self.y2 >= other.y1)

    def create_empty_map(width, height):
        return [[WALL for _ in range(height)] for _ in range(width)]

    def carve_room(dmap, room):
        for x in range(room.x1, room.x2):
            for y in range(room.y1, room.y2):
                dmap[x][y] = FLOOR

    def carve_h_tunnel(dmap, x1, x2, y):
        for x in range(min(x1, x2), max(x1, x2) + 1):
            dmap[x][y] = FLOOR

    def carve_v_tunnel(dmap, y1, y2, x):
        for y in range(min(y1, y2), max(y1, y2) + 1):
            dmap[x][y] = FLOOR

    def _find_room_floor(room, dmap):
        candidates = [
            (x, y)
            for x in range(room.x1, room.x2)
            for y in range(room.y1, room.y2)
            if dmap[x][y] == FLOOR
        ]
        if candidates:
            return random.choice(candidates)
        return (room.x1, room.y1)

    dmap = create_empty_map(width, height)
    rooms = []

    for i in range(max_rooms):
        w = random.randint(room_min_size, room_max_size)
        h = random.randint(room_min_size, room_max_size)
        x = random.randint(1, width - w - 1)
        y = random.randint(1, height - h - 1)
        new_room = Room(x, y, w, h)

        if any(new_room.intersect(other) for other in rooms):
            logging.debug(f"Room {i+1}: Overlaps existing room, skipping placement.")
            continue
        carve_room(dmap, new_room)

        if rooms:
            (prev_x, prev_y) = rooms[-1].center()
            (new_x, new_y) = new_room.center()
            if random.randint(0, 1) == 0:
                carve_h_tunnel(dmap, prev_x, new_x, prev_y)
                carve_v_tunnel(dmap, prev_y, new_y, new_x)
            else:
                carve_v_tunnel(dmap, prev_y, new_y, prev_x)
                carve_h_tunnel(dmap, prev_x, new_x, new_y)
        rooms.append(new_room)
        logging.debug(f"Room {i+1}: Placed at ({x},{y}) size {w}x{h}.")

    if rooms:
        sx, sy = rooms[0].center()
        if dmap[sx][sy] != FLOOR:
            logging.warning("Player start not on floor, correcting.")
            sx, sy = _find_room_floor(rooms[0], dmap)
        ex, ey = rooms[-1].center()
        if dmap[ex][ey] != FLOOR:
            logging.warning("Exit not on floor, correcting.")
            ex, ey = _find_room_floor(rooms[-1], dmap)
        start_x, start_y = sx, sy
        exit_x, exit_y = ex, ey
    else:
        logging.error("No rooms were placed! Using fallback (1,1) for player/exit.")
        start_x = start_y = exit_x = exit_y = 1

    dmap_row_major = [[dmap[x][y] for x in range(len(dmap))] for y in range(len(dmap[0]))]

    logging.info(
        f"Map generation complete: {len(rooms)} rooms placed. "
        f"Player at ({start_x},{start_y}), exit at ({exit_x},{exit_y}), seed={seed}"
    )
    return dmap_row_major, (start_x, start_y), (exit_x, exit_y)

def place_entity(dmap, occupied=None, floor_tile='.'):
    """
    Returns a random (x, y) coordinate on a floor tile (specified by floor_tile) that is not in occupied.
    Raises ValueError if no valid tile is available.
    Assumes dmap is row-major (map[y][x]).
    """
    height = len(dmap)
    width = len(dmap[0])
    occupied = occupied or set()
    floor_tiles = [
        (x, y)
        for y in range(height)
        for x in range(width)
        if dmap[y][x] == floor_tile and (x, y) not in occupied
    ]
    if not floor_tiles:
        logging.error("No available floor tiles for entity placement!")
        raise ValueError("No available floor tiles for entity placement!")
    pos = random.choice(floor_tiles)
    logging.debug(f"Entity placed at {pos} (floor_tile='{floor_tile}').")
    return pos

def print_map(dmap):
    height = len(dmap)
    width = len(dmap[0])
    for y in range(height):
        line = ''.join(dmap[y][x] for x in range(width))
        print(line)

if __name__ == "__main__":
    WIDTH = 40
    HEIGHT = 22
    map_config = {
        "max_rooms": 8,
        "room_min_size": 4,
        "room_max_size": 8,
        "tileset": {
            "wall": "#",
            "floor": "."
        },
        "seed": None
    }
    dungeon_map, (start_x, start_y), (exit_x, exit_y) = generate_map(
        WIDTH, HEIGHT, map_config
    )
    print_map(dungeon_map)
    logging.debug(f"Player start: ({start_x}, {start_y})")
    logging.debug(f"Exit: ({exit_x}, {exit_y})")
